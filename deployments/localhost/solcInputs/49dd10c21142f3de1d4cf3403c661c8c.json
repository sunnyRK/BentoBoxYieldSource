{
  "language": "Solidity",
  "sources": {
    "contracts/BentoBoxPlus.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// The BentoBox Plus\r\n\r\n//  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄ \r\n//  ▐█ ▀█▪▀▄.▀·█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪\r\n//  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██· \r\n//  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌ Plus!!\r\n//  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀\r\n\r\n// This contract stores funds, handles their transfers.\r\n\r\n// Copyright (c) 2020 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// WARNING!!! DO NOT USE!!! UNDER DEVELOPMENT!!!\r\n\r\n// solhint-disable avoid-low-level-calls\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@bartjman/boring-solidity/contracts/libraries/BoringERC20.sol\";\r\nimport \"@bartjman/boring-solidity/contracts/libraries/BoringRebase.sol\";\r\nimport \"@bartjman/boring-solidity/contracts/BoringFactory.sol\";\r\nimport \"@bartjman/boring-solidity/contracts/BoringBatchable.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\nimport \"./MasterContractManager.sol\";\r\n\r\ninterface IFlashLoaner {\r\n    function executeOperation(IERC20[] calldata tokens, uint256[] calldata amounts, uint256[] calldata fees, bytes calldata params) external;\r\n}\r\n\r\ninterface IStrategy {\r\n    function balanceOf() external returns (uint256 amount);\r\n\r\n    // Send the assets to the Strategy and call skim to invest them\r\n    function skim() external returns (uint256 amount);\r\n\r\n    // Harvest any profits made converted to the asset and pass them to the caller\r\n    function harvest() external returns (uint256 amount);\r\n\r\n    // Withdraw assets. Withdraw will call harvest first. The returned amount includes the harvested amount.\r\n    function withdraw(uint256 amount) external returns (uint256 totalAmount);\r\n}\r\n\r\n// Note: Rebasing tokens ARE NOT supported and WILL cause loss of funds\r\ncontract BentoBoxPlus is BoringFactory, MasterContractManager, BoringBatchable {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n    using BoringERC20 for IERC20;\r\n    using RebaseLibrary for Rebase;\r\n\r\n    // E1: OK\r\n    event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\r\n    // E1: OK\r\n    event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\r\n    event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 share);\r\n    event LogFlashLoan(address indexed receiver, IERC20 indexed token, uint256 amount, uint256 feeAmount, address indexed user);\r\n\r\n    // V2: Private to save gas, to verify it's correct, check the constructor arguments\r\n    IERC20 private immutable wethToken;\r\n    mapping(IERC20 => mapping(address => uint256)) public balanceOf; // Balance per token per address/contract\r\n    mapping(IERC20 => Rebase) public totals;\r\n\r\n    constructor(IERC20 wethToken_) public {\r\n        wethToken = wethToken_;\r\n    }\r\n\r\n    function toShare(IERC20 token, uint256 amount) external view returns(uint256 share) {\r\n        return totals[token].toShare(amount);\r\n    }\r\n\r\n    function toAmount(IERC20 token, uint256 share) external view returns(uint256 amount) {\r\n        return totals[token].toAmount(share);\r\n    }\r\n\r\n    // M1 - M5: OK\r\n    // C1 - C23: OK\r\n    modifier allowed(address from) {\r\n        if (from != msg.sender && from != address(this)) {\r\n            address masterContract = masterContractOf[msg.sender];\r\n            require(masterContract != address(0), \"BentoBox: no masterContract\");\r\n            require(masterContractApproved[masterContract][from], \"BentoBox: Transfer not approved\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    // F1 - F10: OK\r\n    // F3: Combined deposit(s) and skim functions into one\r\n    // C1 - C21: OK\r\n    // C2: wethToken is used multiple times, but this is an immutable, so after construction it's hardcoded in the contract\r\n    function deposit(\r\n        IERC20 token_, address from, address to, uint256 amount, uint256 share\r\n    ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {\r\n        // Checks\r\n        require(to != address(0) || from == address(this), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n\r\n        // Effects\r\n        IERC20 token = token_ == IERC20(0) ? wethToken : token_;\r\n        Rebase memory total = totals[token];\r\n\r\n        // Skim\r\n        if (from == address(this)) {\r\n            // S1 - S4: OK\r\n            amount = token_ == IERC20(0) ? address(this).balance : token.balanceOf(address(this)).sub(total.amount);\r\n            share = 0;\r\n        }\r\n\r\n        // S1 - S4: OK\r\n        require(total.amount != 0 || token.totalSupply() > 0, \"BentoBox: No tokens\");\r\n        if (share == 0) { share = total.toShare(amount); } else { amount = total.toAmount(share); }\r\n\r\n        // If to is not address(0) add the share, otherwise skip this to take profit\r\n        if (to != address(0)) {\r\n            balanceOf[token][to] = balanceOf[token][to].add(share);\r\n            total.share = total.share.add(share.to128());\r\n        }\r\n        total.amount = total.amount.add(amount.to128());\r\n        totals[token] = total;\r\n\r\n        // Interactions\r\n        // During the first deposit, we check that this token is 'real'\r\n        if (token_ == IERC20(0)) {\r\n            // X1 - X5: OK\r\n            // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)\r\n            IWETH(address(wethToken)).deposit{value: amount}();\r\n        } else if (from != address(this)) {\r\n            // X1 - X5: OK\r\n            // X2: If the token implementation is faulty or malicious, it will block adding tokens. Good.\r\n            token.safeTransferFrom(from, address(this), amount);\r\n        }\r\n        emit LogDeposit(token, from, to, amount, share);\r\n        amountOut = amount;\r\n        shareOut = share;\r\n    }\r\n\r\n    // F1 - F10: OK\r\n    // C1 - C22: OK\r\n    // C2: wethToken is used multiple times, but this is an immutable, so after construction it's hardcoded in the contract\r\n    function withdraw(\r\n        IERC20 token_, address from, address to, uint256 amount, uint256 share\r\n    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {\r\n        // Checks\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n\r\n        // Effects\r\n        IERC20 token = token_ == IERC20(0) ? wethToken : token_;\r\n        Rebase memory total = totals[token];\r\n        if (share == 0) { share = total.toShare(amount); } else { amount = total.toAmount(share); }\r\n\r\n        balanceOf[token][from] = balanceOf[token][from].sub(share);\r\n        total.amount = total.amount.sub(amount.to128());\r\n        total.share = total.share.sub(share.to128());\r\n        // There have to be at least 100000 shares left at all times to prevent reseting the share/amount ratio\r\n        require(total.share >= 100000, \"BentoBox: cannot empty\");\r\n        totals[token] = total;\r\n\r\n        // Interactions\r\n        if (token_ == IERC20(0)) {\r\n            // X1 - X5: OK\r\n            // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.\r\n            IWETH(address(wethToken)).withdraw(amount);\r\n            // X1 - X5: OK\r\n            // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.\r\n            (bool success,) = to.call{value: amount}(\"\");\r\n            require(success, \"BentoBox: ETH transfer failed\");\r\n        } else {\r\n            // X1 - X5: OK\r\n            // X2, X3: A malicious token could block withdrawal of just THAT token.\r\n            //         masterContracts may want to take care not to rely on withdraw always succeeding.\r\n            token.safeTransfer(to, amount);\r\n        }\r\n        emit LogWithdraw(token, from, to, amount, share);\r\n        amountOut = amount;\r\n        shareOut = share;\r\n    }\r\n\r\n    // *** Approved contract actions *** //\r\n    // Clones of master contracts can transfer from any account that has approved them\r\n    // C2: This isn't combined with transferMultiple for gas optimization\r\n    function transfer(IERC20 token, address from, address to, uint256 share) public allowed(from) {\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n        balanceOf[token][from] = balanceOf[token][from].sub(share);\r\n        balanceOf[token][to] = balanceOf[token][to].add(share);\r\n\r\n        emit LogTransfer(token, from, to, share);\r\n    }\r\n\r\n    // C2: This isn't combined with transfer for gas optimization\r\n    function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) public allowed(from) {\r\n        require(tos[0] != address(0), \"BentoBox: to[0] not set\"); // To avoid a bad UI from burning funds\r\n        uint256 totalAmount;\r\n        for (uint256 i=0; i < tos.length; i++) {\r\n            address to = tos[i];\r\n            balanceOf[token][to] = balanceOf[token][to].add(shares[i]);\r\n            totalAmount = totalAmount.add(shares[i]);\r\n            emit LogTransfer(token, from, to, shares[i]);\r\n        }\r\n        balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);\r\n    }\r\n\r\n    // Take out a flash loan\r\n    function flashLoan(address receiver, IERC20[] calldata tokens, uint256[] calldata amounts, address user, bytes calldata params) public {\r\n        uint256[] memory feeAmounts = new uint256[](tokens.length);\r\n        \r\n        uint256 length = tokens.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            uint256 amount = amounts[i];\r\n            feeAmounts[i] = amount.mul(5) / 10000;\r\n\r\n            tokens[i].safeTransfer(receiver, amounts[i]);\r\n        }\r\n\r\n        IFlashLoaner(user).executeOperation(tokens, amounts, feeAmounts, params);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            Rebase memory total = totals[tokens[i]];\r\n            IERC20 token = tokens[i];\r\n            uint128 feeAmount = feeAmounts[i].to128();\r\n            require(token.balanceOf(address(this)) == total.amount.add(feeAmount), \"BentoBoxPlus: Wrong amount\");\r\n            total.amount = total.amount.add(feeAmount);\r\n            totals[token] = total;\r\n            emit LogFlashLoan(receiver, token, amounts[i], feeAmounts[i], user);\r\n        }\r\n    }\r\n\r\n    // solhint-disable-next-line no-empty-blocks\r\n    receive() external payable {}\r\n}\r\n"
    },
    "@bartjman/boring-solidity/contracts/libraries/BoringERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\n\r\nimport \"../interfaces/IERC20.sol\";\r\n\r\nlibrary BoringERC20 {\r\n    function safeSymbol(IERC20 token) internal view returns(string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\r\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n    }\r\n\r\n    function safeName(IERC20 token) internal view returns(string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\r\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n    }\r\n\r\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\r\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\r\n    }\r\n}"
    },
    "@bartjman/boring-solidity/contracts/libraries/BoringRebase.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\nimport \"./BoringMath.sol\";\r\n\r\nstruct Rebase {\r\n    uint128 amount;\r\n    uint128 share;\r\n}\r\n\r\nlibrary RebaseLibrary {\r\n    using BoringMath for uint256;\r\n\r\n    function toShare(Rebase memory total, uint256 amount) internal pure returns (uint256 share) {\r\n        share = total.amount == 0 ? amount : amount.mul(total.share) / total.amount;\r\n    }\r\n\r\n    function toAmount(Rebase memory total, uint256 share) internal pure returns (uint256 amount) {\r\n        amount = total.share == 0 ? share : share.mul(total.amount) / total.share;\r\n    }\r\n}"
    },
    "@bartjman/boring-solidity/contracts/BoringFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n// solhint-disable no-inline-assembly\r\n\r\npragma solidity 0.6.12;\r\nimport \"./interfaces/IMasterContract.sol\";\r\n\r\ncontract BoringFactory {\r\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\r\n\r\n    mapping(address => address) public masterContractOf; // Mapping from clone contracts to their masterContract\r\n\r\n    // Deploys a given master Contract as a clone.\r\n    function deploy(address masterContract, bytes calldata data) public payable {\r\n        require(masterContract != address(0), \"BoringFactory: No masterContract\");\r\n        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address\r\n        address cloneAddress; // Address where the clone contract will reside.\r\n\r\n        // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            cloneAddress := create(0, clone, 0x37)\r\n        }\r\n        masterContractOf[cloneAddress] = masterContract;\r\n\r\n        IMasterContract(cloneAddress).init{value: msg.value}(data);\r\n\r\n        emit LogDeploy(masterContract, data, cloneAddress);\r\n    }\r\n}"
    },
    "@bartjman/boring-solidity/contracts/BoringBatchable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\r\n\r\n// P1 - P3: OK\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n// solhint-disable avoid-low-level-calls\r\n\r\nimport \"./libraries/BoringERC20.sol\";\r\n\r\n// T1 - T4: OK\r\ncontract BaseBoringBatchable {\r\n    // F3 - F9: OK\r\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\r\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\r\n    // C1 - C21: OK\r\n    // C3: The length of the loop is fully under user control, so can't be exploited\r\n    // C7: Delegatecall is only used on the same contract, so it's safe\r\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns(bool[] memory successes, bytes[] memory results) {\r\n        // Interactions\r\n        successes = new bool[](calls.length);\r\n        results = new bytes[](calls.length);\r\n        for (uint256 i = 0; i < calls.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\r\n            require(success || !revertOnFail, \"BoringBatchable: Tx failed\");\r\n            successes[i] = success;\r\n            results[i] = result;\r\n        }\r\n    }\r\n}\r\n\r\n// T1 - T4: OK\r\ncontract BoringBatchable is BaseBoringBatchable {\r\n    // F1 - F9: OK\r\n    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\r\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\r\n    // C1 - C21: OK\r\n    function permit(IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\r\n        // Interactions\r\n        // X1 - X5\r\n        token.permit(from, to, amount, deadline, v, r, s);\r\n    }\r\n}"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function withdraw(uint256) external;\r\n}\r\n"
    },
    "contracts/MasterContractManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\r\n\r\n// P1 - P3: OK\r\npragma solidity 0.6.12;\r\nimport \"@bartjman/boring-solidity/contracts/BoringOwnable.sol\";\r\n// solhint-disable no-inline-assembly\r\n\r\n// T1 - T4: OK\r\ncontract MasterContractManager is BoringOwnable {\r\n    // E1: OK\r\n    event LogWhiteListMasterContract(address indexed masterContract, bool approved);\r\n    // E1: OK\r\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);\r\n\r\n    // V1 - V5: OK\r\n    mapping(address => mapping(address => bool)) public masterContractApproved; // masterContract to user to approval state\r\n    // V1 - V5: OK\r\n    mapping(address => bool) public whitelistedMasterContracts;\r\n    // V1 - V5: OK\r\n    mapping(address => uint256) public nonces;\r\n\r\n    // F1 - F8: OK\r\n    // C1 - C19: OK\r\n    // C20: Recalculating the domainSeparator is cheaper than reading it from storage\r\n    function domainSeparator() private view returns (bytes32) {\r\n        uint256 chainId;\r\n        assembly {chainId := chainid()}\r\n        return keccak256(abi.encode(\r\n            keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"), \r\n            \"BentoBox V2\",\r\n            chainId, \r\n            address(this)\r\n        ));\r\n    }\r\n\r\n    // F1 - F9: OK\r\n    // F4: Approving masterContract 0 would be very bad, however it cannot be approved by the user and the owner should know better\r\n    // C1 - C21: OK\r\n    function whitelistMasterContract(address masterContract, bool approved) public onlyOwner {\r\n        whitelistedMasterContracts[masterContract] = approved;\r\n        emit LogWhiteListMasterContract(masterContract, approved);\r\n    }\r\n\r\n    // F1 - F9: OK\r\n    // F4: Don't allow masterContract 0 to be approved. Unknown contracts will have a masterContract of 0.\r\n    // F4: User can't be 0 for signed approvals because the recoveredAddress will be 0 if ecrecover fails\r\n    // C1 - C21: OK\r\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) public {\r\n        // Checks\r\n        require(masterContract != address(0), \"MasterCMgr: masterC not set\"); // Important for security\r\n\r\n        // If no signature is provided, the fallback is executed\r\n        if (r == 0  && s == 0 && v == 0) {\r\n            require(user == msg.sender, \"MasterCMgr: user not sender\");\r\n            require(whitelistedMasterContracts[masterContract], \"MasterCMgr: not whitelisted\");\r\n        } else {\r\n            require(user != address(0), \"MasterCMgr: User cannot be 0\"); // Important for security\r\n            // C10: nonce + chainId are used to prevent replays\r\n            // C11: signature is EIP-712 compliant\r\n            // C12: abi.encodePacked has fixed length parameters\r\n            bytes32 digest = keccak256(abi.encodePacked(\r\n                \"\\x19\\x01\", domainSeparator(),\r\n                keccak256(abi.encode(\r\n                    // keccak256(\"SetMasterContractApproval(string warning,address user,address masterContract,bool approved,uint256 nonce)\");\r\n                    0x1962bc9f5484cb7a998701b81090e966ee1fce5771af884cceee7c081b14ade2,\r\n                    approved ? \"Give FULL access to funds in (and approved to) BentoBox?\" : \"Revoke access to BentoBox?\",\r\n                    user, masterContract, approved, nonces[user]++\r\n                ))\r\n            ));\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n            require(recoveredAddress == user, \"MasterCMgr: Invalid Signature\");\r\n        }\r\n\r\n        // Effects\r\n        masterContractApproved[masterContract][user] = approved;\r\n        emit LogSetMasterContractApproval(masterContract, user, approved);\r\n    }\r\n}"
    },
    "@bartjman/boring-solidity/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    // EIP 2612\r\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}"
    },
    "@bartjman/boring-solidity/contracts/libraries/BoringMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n// a library for performing overflow-safe math, updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math)\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a + b) >= b, \"BoringMath: Add Overflow\");}\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a - b) <= a, \"BoringMath: Underflow\");}\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {require(b == 0 || (c = a * b)/b == a, \"BoringMath: Mul Overflow\");}\r\n    function to128(uint256 a) internal pure returns (uint128 c) {\r\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\r\n        c = uint128(a);\r\n    }\r\n}\r\n\r\nlibrary BoringMath128 {\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a + b) >= b, \"BoringMath: Add Overflow\");}\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a - b) <= a, \"BoringMath: Underflow\");}\r\n}"
    },
    "@bartjman/boring-solidity/contracts/interfaces/IMasterContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IMasterContract {\r\n    function init(bytes calldata data) external payable;\r\n}"
    },
    "@bartjman/boring-solidity/contracts/BoringOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\r\n\r\n// P1 - P3: OK\r\npragma solidity 0.6.12;\r\n\r\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\r\n// Edited by BoringCrypto\r\n\r\n// T1 - T4: OK\r\ncontract BoringOwnableData {\r\n    // V1 - V5: OK\r\n    address public owner;\r\n    // V1 - V5: OK\r\n    address public pendingOwner;\r\n}\r\n\r\n// T1 - T4: OK\r\ncontract BoringOwnable is BoringOwnableData {\r\n    // E1: OK\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () public {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    // F1 - F9: OK\r\n    // C1 - C21: OK\r\n    function transferOwnership(address newOwner, bool direct, bool renounce) public onlyOwner {\r\n        if (direct) {\r\n            // Checks\r\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\r\n\r\n            // Effects\r\n            emit OwnershipTransferred(owner, newOwner);\r\n            owner = newOwner;\r\n            pendingOwner = address(0);\r\n        } else {\r\n            // Effects\r\n            pendingOwner = newOwner;\r\n        }\r\n    }\r\n\r\n    // F1 - F9: OK\r\n    // C1 - C21: OK\r\n    function claimOwnership() public {\r\n        address _pendingOwner = pendingOwner;\r\n        \r\n        // Checks\r\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\r\n\r\n        // Effects\r\n        emit OwnershipTransferred(owner, _pendingOwner);\r\n        owner = _pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    // M1 - M5: OK\r\n    // C1 - C21: OK\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}"
    },
    "contracts/mocks/LendingPairMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../BentoBoxPlus.sol\";\r\nimport \"../LendingPair.sol\";\r\n\r\ncontract LendingPairMock is LendingPair {\r\n    \r\n    constructor(BentoBoxPlus bentoBox) public LendingPair(bentoBox) {}\r\n\r\n    function setInterestPerBlock(uint64 interestPerBlock) public {\r\n        accrueInfo.interestPerBlock = interestPerBlock;\r\n    }\r\n    \r\n}\r\n"
    },
    "contracts/LendingPair.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// Medium Risk LendingPair\r\n\r\n// ▄▄▌  ▄▄▄ . ▐ ▄ ·▄▄▄▄  ▪   ▐ ▄  ▄▄ •  ▄▄▄· ▄▄▄· ▪  ▄▄▄\r\n// ██•  ▀▄.▀·•█▌▐███▪ ██ ██ •█▌▐█▐█ ▀ ▪▐█ ▄█▐█ ▀█ ██ ▀▄ █·\r\n// ██▪  ▐▀▀▪▄▐█▐▐▌▐█· ▐█▌▐█·▐█▐▐▌▄█ ▀█▄ ██▀·▄█▀▀█ ▐█·▐▀▀▄\r\n// ▐█▌▐▌▐█▄▄▌██▐█▌██. ██ ▐█▌██▐█▌▐█▄▪▐█▐█▪·•▐█ ▪▐▌▐█▌▐█•█▌\r\n// .▀▀▀  ▀▀▀ ▀▀ █▪▀▀▀▀▀• ▀▀▀▀▀ █▪·▀▀▀▀ .▀    ▀  ▀ ▀▀▀.▀  ▀\r\n\r\n// Copyright (c) 2020 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// Special thanks to:\r\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\r\n\r\n// WARNING!!! DO NOT USE!!! BEING AUDITED!!!\r\n\r\n// solhint-disable avoid-low-level-calls\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@bartjman/boring-solidity/contracts/libraries/BoringMath.sol\";\r\nimport \"@bartjman/boring-solidity/contracts/BoringOwnable.sol\";\r\nimport \"@bartjman/boring-solidity/contracts/ERC20.sol\";\r\nimport \"@bartjman/boring-solidity/contracts/interfaces/IMasterContract.sol\";\r\nimport \"./interfaces/IOracle.sol\";\r\nimport \"./BentoBoxPlus.sol\";\r\nimport \"./interfaces/ISwapper.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\n\r\n// TODO: check all reentrancy paths\r\n// TODO: what to do when the entire pool is underwater?\r\n// TODO: check that all actions on a users funds can only be initiated by that user as msg.sender\r\n\r\ncontract LendingPair is ERC20, BoringOwnable, BoringBatchable, IMasterContract {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n    using RebaseLibrary for Rebase;\r\n\r\n    // MasterContract variables\r\n    BentoBoxPlus public immutable bentoBox;\r\n    LendingPair public immutable masterContract;\r\n    address public feeTo;\r\n    mapping(ISwapper => bool) public swappers;\r\n\r\n    // Per clone variables\r\n    // Clone settings\r\n    IERC20 public collateral;\r\n    IERC20 public asset;\r\n    IOracle public oracle;\r\n    bytes public oracleData;\r\n\r\n    // User balances\r\n    mapping(address => uint256) public userCollateralShare;\r\n    // userAssetFraction is called balanceOf for ERC20 compatibility\r\n    mapping(address => uint256) public userBorrowPart;\r\n\r\n    struct TokenTotals {\r\n        uint128 share;\r\n        uint128 fraction;\r\n    }\r\n\r\n    struct BorrowTokenTotals {\r\n        uint128 amount;\r\n        uint128 part;\r\n    }\r\n\r\n    // Total amounts\r\n    uint256 public totalCollateralShare;\r\n    TokenTotals public totalAsset; // The total assets belonging to the suppliers (including any borrowed amounts).\r\n    BorrowTokenTotals public totalBorrow; // Total units of asset borrowed\r\n\r\n    // totalSupply for ERC20 compatibility\r\n    function totalSupply() public view returns(uint256) {\r\n        return totalAsset.fraction;\r\n    }\r\n\r\n    // Exchange and interest rate tracking\r\n    uint256 public exchangeRate;\r\n\r\n    struct AccrueInfo {\r\n        uint64 interestPerBlock;\r\n        uint64 lastBlockAccrued;\r\n        uint128 feesEarnedFraction;\r\n    }\r\n    uint256 feesPaidAmount;\r\n    AccrueInfo public accrueInfo;\r\n\r\n    // ERC20 'variables'\r\n    function symbol() public view returns(string memory) {\r\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x95d89b41));\r\n        string memory assetSymbol = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        (success, data) = address(collateral).staticcall(abi.encodeWithSelector(0x95d89b41));\r\n        string memory collateralSymbol = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        return string(abi.encodePacked(\"bm\", collateralSymbol, \">\", assetSymbol, \"-\", oracle.symbol(oracleData)));\r\n    }\r\n\r\n    function name() public view returns(string memory) {\r\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x06fdde03));\r\n        string memory assetName = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        (success, data) = address(collateral).staticcall(abi.encodeWithSelector(0x06fdde03));\r\n        string memory collateralName = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        return string(abi.encodePacked(\"Bento Med Risk \", collateralName, \">\", assetName, \"-\", oracle.symbol(oracleData)));\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x313ce567));\r\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n\r\n    event LogExchangeRate(uint256 rate);\r\n    event LogAccrue(uint256 accruedAmount, uint256 feeFraction, uint256 rate, uint256 utilization);\r\n    event LogAddCollateral(address indexed user, uint256 amount);\r\n    event LogAddAsset(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogAddBorrow(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogRemoveCollateral(address indexed user, uint256 amount);\r\n    event LogRemoveAsset(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogRemoveBorrow(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogFeeTo(address indexed newFeeTo);\r\n    event LogWithdrawFees();\r\n\r\n    constructor(BentoBoxPlus bentoBox_) public {\r\n        bentoBox = bentoBox_;\r\n        masterContract = LendingPair(this);\r\n        feeTo = msg.sender;\r\n        emit LogFeeTo(msg.sender);\r\n\r\n        // Not really an issue, but https://blog.trailofbits.com/2020/12/16/breaking-aave-upgradeability/\r\n        collateral = IERC20(address(1));\r\n    }\r\n    \r\n    // Settings for the Medium Risk LendingPair\r\n    uint256 private constant CLOSED_COLLATERIZATION_RATE = 75000; // 75%\r\n    uint256 private constant OPEN_COLLATERIZATION_RATE = 77000; // 77%\r\n    uint256 private constant MINIMUM_TARGET_UTILIZATION = 7e17; // 70%\r\n    uint256 private constant MAXIMUM_TARGET_UTILIZATION = 8e17; // 80%\r\n\r\n    uint256 private constant STARTING_INTEREST_PER_BLOCK = 4566210045; // approx 1% APR\r\n    uint256 private constant MINIMUM_INTEREST_PER_BLOCK = 1141552511; // approx 0.25% APR\r\n    uint256 private constant MAXIMUM_INTEREST_PER_BLOCK = 4566210045000;  // approx 1000% APR\r\n    uint256 private constant INTEREST_ELASTICITY = 2000e36; // Half or double in 2000 blocks (approx 8 hours)\r\n\r\n    uint256 private constant LIQUIDATION_MULTIPLIER = 112000; // add 12%\r\n\r\n    // Fees\r\n    uint256 private constant PROTOCOL_FEE = 10000; // 10%\r\n    uint256 private constant DEV_FEE = 10000; // 10% of the PROTOCOL_FEE = 1%\r\n    uint256 private constant BORROW_OPENING_FEE = 50; // 0.05%\r\n\r\n    // Serves as the constructor, as clones can't have a regular constructor\r\n    function init(bytes calldata data) public payable override {\r\n        require(address(collateral) == address(0), \"LendingPair: already initialized\");\r\n        (collateral, asset, oracle, oracleData) = abi.decode(data, (IERC20, IERC20, IOracle, bytes));\r\n\r\n        accrueInfo.interestPerBlock = uint64(STARTING_INTEREST_PER_BLOCK);  // 1% APR, with 1e18 being 100%\r\n        updateExchangeRate();\r\n    }\r\n\r\n    function getInitData(IERC20 collateral_, IERC20 asset_, IOracle oracle_, bytes calldata oracleData_) public pure returns(bytes memory data) {\r\n        return abi.encode(collateral_, asset_, oracle_, oracleData_);\r\n    }\r\n\r\n    function setApproval(address user, bool approved, uint8 v, bytes32 r, bytes32 s) external {\r\n        bentoBox.setMasterContractApproval(user, address(masterContract), approved, v, r, s);\r\n    }\r\n\r\n    function deposit(IERC20 token, address to, uint256 amount, uint256 share) public payable returns (uint256 amountOut, uint256 shareOut) {\r\n        return bentoBox.deposit(token, msg.sender, to, amount, share);\r\n    }\r\n\r\n    // Add more bentobox wrappers\r\n\r\n    // Accrues the interest on the borrowed tokens and handles the accumulation of fees\r\n    function accrue() public {\r\n        AccrueInfo memory _accrueInfo = accrueInfo;\r\n        // Number of blocks since accrue was called\r\n        uint256 blocks = block.number - _accrueInfo.lastBlockAccrued;\r\n        if (blocks == 0) {return;}\r\n        _accrueInfo.lastBlockAccrued = uint64(block.number);\r\n\r\n        uint256 extraAmount = 0;\r\n        uint256 feeFraction = 0;\r\n\r\n        BorrowTokenTotals memory _totalBorrow = totalBorrow;\r\n        TokenTotals memory _totalAsset = totalAsset;\r\n        if (_totalAsset.fraction == 0) {\r\n            if (_accrueInfo.interestPerBlock != STARTING_INTEREST_PER_BLOCK) {\r\n                _accrueInfo.interestPerBlock = uint64(STARTING_INTEREST_PER_BLOCK);\r\n                emit LogAccrue(0, 0, STARTING_INTEREST_PER_BLOCK, 0);\r\n            }\r\n            return;\r\n        }\r\n\r\n        uint256 totalAssetAmount = bentoBox.toAmount(asset, _totalAsset.share);\r\n        if (_totalBorrow.amount > 0) {\r\n            // Accrue interest\r\n            extraAmount = uint256(_totalBorrow.amount).mul(_accrueInfo.interestPerBlock).mul(blocks) / 1e18;\r\n            uint256 feeAmount = extraAmount.mul(PROTOCOL_FEE) / 1e5; // % of interest paid goes to fee\r\n            _totalBorrow.amount = _totalBorrow.amount.add(extraAmount.to128());\r\n            feeFraction = feeAmount.mul(_totalAsset.fraction) / totalAssetAmount.add(_totalBorrow.amount).sub(feeAmount);\r\n            _accrueInfo.feesEarnedFraction = _accrueInfo.feesEarnedFraction.add(feeFraction.to128());\r\n            _totalAsset.fraction = _totalAsset.fraction.add(feeFraction.to128());\r\n            totalBorrow = _totalBorrow;\r\n        }\r\n\r\n        // Update interest rate\r\n        uint256 utilization = uint256(_totalBorrow.amount).mul(1e18) / totalAssetAmount.add(_totalBorrow.amount);\r\n        uint256 newInterestPerBlock;\r\n        if (utilization < MINIMUM_TARGET_UTILIZATION) {\r\n            uint256 underFactor = MINIMUM_TARGET_UTILIZATION.sub(utilization).mul(1e18) / MINIMUM_TARGET_UTILIZATION;\r\n            uint256 scale = INTEREST_ELASTICITY.add(underFactor.mul(underFactor).mul(blocks));\r\n            newInterestPerBlock = uint256(_accrueInfo.interestPerBlock).mul(INTEREST_ELASTICITY) / scale;\r\n            if (newInterestPerBlock < MINIMUM_INTEREST_PER_BLOCK) {newInterestPerBlock = MINIMUM_INTEREST_PER_BLOCK;} // 0.25% APR minimum\r\n       } else if (utilization > MAXIMUM_TARGET_UTILIZATION) {\r\n            uint256 overFactor = utilization.sub(MAXIMUM_TARGET_UTILIZATION).mul(1e18) / uint256(1e18).sub(MAXIMUM_TARGET_UTILIZATION);\r\n            uint256 scale = INTEREST_ELASTICITY.add(overFactor.mul(overFactor).mul(blocks));\r\n            newInterestPerBlock = uint256(_accrueInfo.interestPerBlock).mul(scale) / INTEREST_ELASTICITY;\r\n            if (newInterestPerBlock > MAXIMUM_INTEREST_PER_BLOCK) {newInterestPerBlock = MAXIMUM_INTEREST_PER_BLOCK;} // 1000% APR maximum\r\n        } else {\r\n            emit LogAccrue(extraAmount, feeFraction, _accrueInfo.interestPerBlock, utilization);\r\n            accrueInfo = _accrueInfo; return;\r\n        }\r\n\r\n        _accrueInfo.interestPerBlock = uint64(newInterestPerBlock);\r\n        emit LogAccrue(extraAmount, feeFraction, newInterestPerBlock, utilization);\r\n        accrueInfo = _accrueInfo;\r\n    }\r\n\r\n    // Checks if the user is solvent.\r\n    // Has an option to check if the user is solvent in an open/closed liquidation case.\r\n    function isSolvent(address user, bool open) public view returns (bool) {\r\n        // accrue must have already been called!\r\n        if (userBorrowPart[user] == 0) return true;\r\n        if (totalCollateralShare == 0) return false;\r\n\r\n        BorrowTokenTotals memory _totalBorrow = totalBorrow;\r\n\r\n        return bentoBox.toAmount(\r\n                collateral, \r\n                userCollateralShare[user].mul(1e13).mul(\r\n                    open \r\n                    ? OPEN_COLLATERIZATION_RATE \r\n                    : CLOSED_COLLATERIZATION_RATE\r\n                )\r\n            ) >= \r\n            userBorrowPart[user]\r\n                .mul(_totalBorrow.amount)\r\n                .mul(exchangeRate)\r\n                / _totalBorrow.part;\r\n    }\r\n\r\n    function peekExchangeRate() public view returns (bool, uint256) {\r\n        return oracle.peek(oracleData);\r\n    }\r\n\r\n    // Gets the exchange rate. How much collateral to buy 1e18 asset.\r\n    function updateExchangeRate() public returns (uint256) {\r\n        (bool success, uint256 rate) = oracle.get(oracleData);\r\n\r\n        // TODO: How to deal with unsuccessful fetch\r\n        if (success) {\r\n            exchangeRate = rate;\r\n            emit LogExchangeRate(rate);\r\n        }\r\n        return exchangeRate;\r\n    }\r\n\r\n    function addCollateral(uint256 share, address to) public {\r\n        userCollateralShare[to] = userCollateralShare[to].add(share);\r\n        totalCollateralShare = totalCollateralShare.add(share);\r\n        emit LogAddCollateral(to, share);\r\n        bentoBox.transfer(collateral, msg.sender, address(this), share);\r\n    }\r\n\r\n    function removeCollateral(uint256 share, address to) public {\r\n        accrue();\r\n        userCollateralShare[msg.sender] = userCollateralShare[msg.sender].sub(share);\r\n        totalCollateralShare = totalCollateralShare.sub(share);\r\n        emit LogRemoveCollateral(msg.sender, share);\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n        bentoBox.transfer(collateral, address(this), to, share);\r\n    }\r\n\r\n    function addAsset(uint256 share, address to) public {\r\n        accrue();\r\n        TokenTotals memory _totalAsset = totalAsset;\r\n        uint256 newFraction = _totalAsset.share == 0 \r\n            ? share \r\n            : share.mul(_totalAsset.fraction) / _totalAsset.share;\r\n        balanceOf[to] = balanceOf[to].add(newFraction);\r\n        _totalAsset.fraction = _totalAsset.fraction.add(newFraction.to128());\r\n        _totalAsset.share = _totalAsset.share.add(share.to128());\r\n        totalAsset = _totalAsset;\r\n        emit LogAddAsset(to, share, newFraction);\r\n        bentoBox.transfer(asset, msg.sender, address(this), share);\r\n    }\r\n\r\n    function removeAsset(uint256 fraction, address to) public {\r\n        accrue();\r\n        TokenTotals memory _totalAsset = totalAsset;\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(fraction);\r\n        // Share - toamount + Your share of borrow - you share of the fees on the borrow\r\n        uint256 share = fraction.mul(_totalAsset.share) / _totalAsset.fraction;\r\n        _totalAsset.fraction = _totalAsset.fraction.sub(fraction.to128());\r\n        _totalAsset.share = _totalAsset.share.sub(share.to128());\r\n        totalAsset = _totalAsset;\r\n        emit LogRemoveAsset(msg.sender, share, fraction);\r\n        bentoBox.transfer(asset, address(this), to, share);\r\n    }\r\n\r\n    function borrow(uint256 amount, address to) public {\r\n        accrue();\r\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / 1e5; // A flat % fee is charged for any borrow\r\n        BorrowTokenTotals memory _totalBorrow = totalBorrow;\r\n        uint256 newFraction = _totalBorrow.amount == 0 ? amount : amount.mul(_totalBorrow.part) / _totalBorrow.amount;\r\n        userBorrowPart[to] = userBorrowPart[to].add(newFraction);\r\n        _totalBorrow.part = _totalBorrow.part.add(newFraction.to128());\r\n        _totalBorrow.amount = _totalBorrow.amount.add(amount.to128());\r\n        totalBorrow = _totalBorrow;\r\n        emit LogAddBorrow(msg.sender, amount, newFraction);\r\n        totalAsset.share = totalAsset.share.add(feeAmount.to128());\r\n        bentoBox.transfer(asset, address(this), to, bentoBox.toShare(asset, amount));\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n    }\r\n\r\n    function repay(uint256 part, address to) public {\r\n        accrue();\r\n        BorrowTokenTotals memory _totalBorrow = totalBorrow;\r\n        userBorrowPart[to] = userBorrowPart[to].sub(part);\r\n        uint256 amount = part.mul(_totalBorrow.amount) / _totalBorrow.part;\r\n        _totalBorrow.part = _totalBorrow.part.sub(part.to128());\r\n        _totalBorrow.amount = _totalBorrow.amount.sub(amount.to128());\r\n        totalBorrow = _totalBorrow;\r\n        emit LogRemoveBorrow(msg.sender, amount, part);\r\n        bentoBox.transfer(asset, msg.sender, address(this), amount);\r\n    }\r\n    /*\r\n    function leverage(\r\n        address to,\r\n        uint256 removeCollateralShare,\r\n        uint256 removeAssetFraction,\r\n        uint256 borrowAmount,\r\n        ISwapper swapper,\r\n        bytes calldata swapperData)\r\n    public {\r\n        accrue();\r\n        if (removeCollateralShare > 0) {\r\n            removeCollateral(removeCollateralShare, to);\r\n        }\r\n\r\n        if (removeAssetFraction > 0) {\r\n            removeAsset(removeAssetFraction, to);\r\n        }\r\n\r\n        if (borrowAmount> 0) {\r\n            //borrow();\r\n        }\r\n\r\n        // Swap\r\n\r\n\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n    }\r\n\r\n    // Handles the liquidation of users' balances, once the users' amount of collateral is too low\r\n    function liquidate(address[] calldata users, uint256[] calldata borrowParts, address to, ISwapper swapper, bool open) public {\r\n        accrue();\r\n        updateExchangeRate();\r\n\r\n        uint256 allCollateralShare = 0;\r\n        uint256 allBorrowAmount = 0;\r\n        uint256 allBorrowPart = 0;\r\n        BorrowTokenTotals memory _totalBorrow = totalBorrow;\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            address user = users[i];\r\n            if (!isSolvent(user, open)) {\r\n                uint256 borrowPart = borrowParts[i];\r\n                uint256 borrowAmount = borrowPart.mul(_totalBorrow.amount) / _totalBorrow.part;\r\n                uint256 collateralAmount = borrowAmount\r\n                    .mul(LIQUIDATION_MULTIPLIER).mul(exchangeRate) / 1e23;\r\n\r\n                userCollateralShare[user] = userCollateralShare[user].sub(collateralAmount);\r\n                userBorrowPart[user] = userBorrowPart[user].sub(borrowPart);\r\n                emit LogRemoveCollateral(user, collateralAmount);\r\n                emit LogRemoveBorrow(user, borrowAmount, borrowPart);\r\n\r\n                // Keep totals\r\n                allCollateralShare = allCollateralShare.add(collateralAmount);\r\n                allBorrowAmount = allBorrowAmount.add(borrowAmount);\r\n                allBorrowPart = allBorrowPart.add(borrowPart);\r\n            }\r\n        }\r\n        require(allBorrowAmount != 0, \"LendingPair: all are solvent\");\r\n        _totalBorrow.amount = _totalBorrow.amount.sub(allBorrowAmount.to128());\r\n        _totalBorrow.part = _totalBorrow.part.sub(allBorrowPart.to128());\r\n        totalBorrow = _totalBorrow;\r\n        totalCollateralShare = totalCollateralShare.sub(allCollateralShare);\r\n\r\n        if (!open) {\r\n            // Closed liquidation using a pre-approved swapper for the benefit of the LPs\r\n            require(masterContract.swappers(swapper), \"LendingPair: Invalid swapper\");\r\n\r\n            // Swaps the users' collateral for the borrowed asset\r\n            bentoBox.transfer(collateral, address(this), address(swapper), allCollateralShare);\r\n            swapper.swap(collateral, asset, allCollateralShare, allBorrowAmount);\r\n\r\n            (uint256 returnedAssetAmount,) = bentoBox.deposit(asset, address(bentoBox), address(this), 0, 0); // TODO: Reentrancy issue? Should we take a before and after balance?\r\n            uint256 extraAssetAmount = returnedAssetAmount.sub(allBorrowAmount);\r\n\r\n            // The extra asset gets added to the pool\r\n            uint256 feeAmount = extraAssetAmount.mul(PROTOCOL_FEE) / 1e5; // % of profit goes to fee\r\n            accrueInfo.feesEarnedAmount = accrueInfo.feesEarnedAmount.add(feeAmount.to128());\r\n            totalAsset.share = totalAsset.share.add(extraAssetAmount.sub(feeAmount).to128());\r\n            emit LogAddAsset(address(0), extraAssetAmount, 0);\r\n        } else {\r\n            // Swap using a swapper freely chosen by the caller\r\n            // Open (flash) liquidation: get proceeds first and provide the borrow after\r\n            bentoBox.transfer(collateral, address(this), to, allCollateralShare);\r\n            if (swapper != ISwapper(0)) {\r\n                swapper.swap(collateral, asset, allCollateralShare, allBorrowAmount);\r\n            }\r\n\r\n            bentoBox.transfer(asset, msg.sender, address(this), allBorrowAmount);\r\n        }\r\n    }\r\n\r\n    // Withdraws the fees accumulated\r\n    function withdrawFees() public {\r\n        accrue();\r\n        address _feeTo = masterContract.feeTo();\r\n        AccrueInfo memory _accrueInfo = accrueInfo;\r\n        TokenTotals memory _totalAsset = totalAsset;\r\n        \r\n        uint256 _feeShare = _totalAsset.toShare(_accrueInfo.feesEarnedFraction);\r\n        _totalAsset.fraction = _totalAsset.fraction.sub(_accrueInfo.feesEarnedFraction);\r\n        _totalAsset.share = _totalAsset.share.sub(_feeShare);\r\n        _accrueInfo.feesEarnedFraction = 0;\r\n        accrueInfo = _accrueInfo;\r\n        totalAsset = _totalAsset;\r\n\r\n        bentoBox.transfer(asset, address(this), _feeTo, _feeShare);\r\n\r\n        emit LogWithdrawFees();\r\n    }\r\n    */\r\n    // MasterContract Only Admin functions\r\n    function setSwapper(ISwapper swapper, bool enable) public onlyOwner {\r\n        swappers[swapper] = enable;\r\n    }\r\n\r\n    function setFeeTo(address newFeeTo) public onlyOwner\r\n    {\r\n        feeTo = newFeeTo;\r\n        emit LogFeeTo(newFeeTo);\r\n    }\r\n\r\n    // Clone contract Admin functions - no error handling because it's admin\r\n    function swipe(IERC20 token) public {\r\n        require(msg.sender == masterContract.owner(), \"LendingPair: caller is not owner\");\r\n\r\n        if (address(token) == address(0)) {\r\n            msg.sender.call{value: address(this).balance}(new bytes(0));\r\n        } else if (address(token) != address(asset) && address(token) != address(collateral)) {\r\n            address(token).call(abi.encodeWithSelector(0xa9059cbb, msg.sender, token.balanceOf(address(this))));\r\n        } else {\r\n            uint256 excessAmount = bentoBox.balanceOf(token, address(this)).sub(token == asset ? totalAsset.share : totalCollateralShare);\r\n            bentoBox.transfer(token, address(this), msg.sender, excessAmount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "@bartjman/boring-solidity/contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// solhint-disable no-inline-assembly\r\n// solhint-disable not-rely-on-time\r\n\r\npragma solidity 0.6.12;\r\n\r\n// Data part taken out for building of contracts that receive delegate calls\r\ncontract ERC20Data {\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping (address => uint256)) public allowance;\r\n    mapping(address => uint256) public nonces;\r\n}\r\n\r\ncontract ERC20 is ERC20Data {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function transfer(address to, uint256 amount) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= amount, \"ERC20: balance too low\");\r\n        // The following check is pretty much in all ERC20 contracts, but this can only fail if totalSupply >= 2^256\r\n        require(balanceOf[to] + amount >= balanceOf[to], \"ERC20: overflow detected\");\r\n        balanceOf[msg.sender] -= amount;\r\n        balanceOf[to] += amount;\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 amount) public returns (bool success) {\r\n        require(balanceOf[from] >= amount, \"ERC20: balance too low\");\r\n        require(allowance[from][msg.sender] >= amount, \"ERC20: allowance too low\");\r\n        // The following check is pretty much in all ERC20 contracts, but this can only fail if totalSupply >= 2^256\r\n        require(balanceOf[to] + amount >= balanceOf[to], \"ERC20: overflow detected\");\r\n        balanceOf[from] -= amount;\r\n        allowance[from][msg.sender] -= amount;\r\n        balanceOf[to] += amount;\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool success) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() public view returns (bytes32){\r\n      uint256 chainId;\r\n      assembly {chainId := chainid()}\r\n      return keccak256(abi.encode(keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\"), chainId, address(this)));\r\n    }\r\n\r\n    function permit(address owner_, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\r\n        require(block.timestamp < deadline, \"ERC20: Expired\");\r\n        bytes32 digest = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\", DOMAIN_SEPARATOR(),\r\n            keccak256(abi.encode(\r\n                // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n                0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,\r\n                owner_, spender, value, nonces[owner_]++, deadline\r\n            ))\r\n        ));\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress == owner_, \"ERC20: Invalid Signature\");\r\n        allowance[owner_][spender] = value;\r\n        emit Approval(owner_, spender, value);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IOracle {\r\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\r\n    function get(bytes calldata data) external returns (bool, uint256);\r\n    function peek(bytes calldata data) external view returns (bool, uint256);\r\n    function symbol(bytes calldata data) external view returns (string memory);\r\n    function name(bytes calldata data) external view returns (string memory);\r\n}"
    },
    "contracts/interfaces/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"./IBentoBox.sol\";\r\n\r\ninterface ISwapper {\r\n    // Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper\r\n    // Swaps it for at least 'amountToMin' of token 'to'\r\n    // Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer\r\n    // Returns the amount of tokens 'to' transferred to BentoBox\r\n    // (The BentoBox skim function will be used by the caller to get the swapped funds)\r\n    function swap(IERC20 from, IERC20 to, uint256 amountFrom, uint256 amountToMin) external returns (uint256 amountTo);\r\n\r\n    // Calculates the amount of token 'from' needed to complete the swap (amountFrom), this should be less than or equal to amountFromMax\r\n    // Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper\r\n    // Swaps it for exactly 'exactAmountTo' of token 'to'\r\n    // Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer\r\n    // Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom)\r\n    // Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom)\r\n    // (The BentoBox skim function will be used by the caller to get the swapped funds)\r\n    function swapExact(\r\n        IERC20 from, IERC20 to, uint256 amountFromMax,\r\n        uint256 exactAmountTo, address refundTo\r\n    ) external returns (uint256 amountFrom);\r\n}"
    },
    "contracts/interfaces/IBentoBox.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\nimport \"@bartjman/boring-solidity/contracts/interfaces/IERC20.sol\";\r\n\r\ninterface IBentoBox {\r\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\r\n    event LogDeposit(address indexed token, address indexed from, address indexed to, uint256 amount);\r\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool indexed approved);\r\n    event LogTransfer(address indexed token, address indexed from, address indexed to, uint256 amount);\r\n    event LogWithdraw(address indexed token, address indexed from, address indexed to, uint256 amount);\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function WETH() external view returns (IERC20);\r\n    function balanceOf(IERC20, address) external view returns (uint256);\r\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\r\n    function deploy(address masterContract, bytes calldata data) external;\r\n    function deposit(IERC20 token, address from, uint256 amount) external payable;\r\n    function depositTo(IERC20 token, address from, address to, uint256 amount) external payable;\r\n    function masterContractApproved(address, address) external view returns (bool);\r\n    function masterContractOf(address) external view returns (address);\r\n    function nonces(address) external view returns (uint256);\r\n    function permit(IERC20 token, address from, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;\r\n    function skim(IERC20 token) external returns (uint256 amount);\r\n    function skimETH() external returns (uint256 amount);\r\n    function skimETHTo(address to) external returns (uint256 amount);\r\n    function skimTo(IERC20 token, address to) external returns (uint256 amount);\r\n    function totalSupply(IERC20) external view returns (uint256);\r\n    function transfer(IERC20 token, address to, uint256 amount) external;\r\n    function transferFrom(IERC20 token, address from, address to, uint256 amount) external;\r\n    function transferMultiple(IERC20 token, address[] calldata tos, uint256[] calldata amounts) external;\r\n    function transferMultipleFrom(IERC20 token, address from, address[] calldata tos, uint256[] calldata amounts) external;\r\n    function withdraw(IERC20 token, address to, uint256 amount) external;\r\n    function withdrawFrom(IERC20 token, address from, address to, uint256 amount) external;\r\n}"
    },
    "contracts/swappers/SushiSwapSwapper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\nimport \"@bartjman/boring-solidity/contracts/libraries/BoringMath.sol\";\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\r\nimport \"@bartjman/boring-solidity/contracts/interfaces/IERC20.sol\";\r\nimport \"../interfaces/ISwapper.sol\";\r\n\r\ncontract SushiSwapSwapper is ISwapper {\r\n    using BoringMath for uint256;\r\n\r\n    // Local variables\r\n    IBentoBox public bentoBox;\r\n    IUniswapV2Factory public factory;\r\n\r\n    constructor(IBentoBox bentoBox_, IUniswapV2Factory factory_) public {\r\n        bentoBox = bentoBox_;\r\n        factory = factory_;\r\n    }\r\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) internal pure returns (uint256 amountOut) {\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        uint256 numerator = amountInWithFee.mul(reserveOut);\r\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) internal pure returns (uint256 amountIn) {\r\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // Swaps to a flexible amount, from an exact input amount\r\n    function swap(IERC20 from, IERC20 to, uint256 amountFrom, uint256 amountToMin) public override returns (uint256) {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(address(from), address(to)));\r\n\r\n        bentoBox.withdraw(from, address(pair), amountFrom);\r\n\r\n        (uint256 reserve0, uint256 reserve1,) = pair.getReserves();\r\n        uint256 amountTo;\r\n        if (pair.token0() == address(from)) {\r\n            amountTo = getAmountOut(amountFrom, reserve0, reserve1);\r\n            require(amountTo >= amountToMin, \"SushiSwapSwapper: not enough\");\r\n            pair.swap(0, amountTo, address(bentoBox), new bytes(0));\r\n        } else {\r\n            amountTo = getAmountOut(amountFrom, reserve1, reserve0);\r\n            require(amountTo >= amountToMin, \"SushiSwapSwapper: not enough\");\r\n            pair.swap(amountTo, 0, address(bentoBox), new bytes(0));\r\n        }\r\n        return amountTo;\r\n    }\r\n\r\n    // Swaps to an exact amount, from a flexible input amount\r\n    function swapExact(\r\n        IERC20 from, IERC20 to, uint256 amountFromMax, uint256 exactAmountTo, address refundTo\r\n    ) public override returns (uint256) {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(address(from), address(to)));\r\n\r\n        (uint256 reserve0, uint256 reserve1,) = pair.getReserves();\r\n\r\n        uint256 amountFrom;\r\n        if (pair.token0() == address(from)) {\r\n            amountFrom = getAmountIn(exactAmountTo, reserve0, reserve1);\r\n            require(amountFrom <= amountFromMax, \"SushiSwapSwapper: not enough\");\r\n            bentoBox.withdraw(from, address(pair), amountFrom);\r\n            pair.swap(0, exactAmountTo, address(bentoBox), new bytes(0));\r\n        } else {\r\n            amountFrom = getAmountIn(exactAmountTo, reserve1, reserve0);\r\n            require(amountFrom <= amountFromMax, \"SushiSwapSwapper: not enough\");\r\n            bentoBox.withdraw(from, address(pair), amountFrom);\r\n            pair.swap(exactAmountTo, 0, address(bentoBox), new bytes(0));\r\n        }\r\n\r\n        bentoBox.transferFrom(from, address(this), refundTo, amountFromMax.sub(amountFrom));\r\n\r\n        return amountFrom;\r\n    }\r\n}\r\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function setMigrator(address) external;\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/interfaces/ILendingPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// solhint-disable func-name-mixedcase\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\nimport \"./IOracle.sol\";\r\nimport \"./ISwapper.sol\";\r\nimport \"./IBentoBox.sol\";\r\n\r\ninterface ILendingPair {\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event LogAccrue(uint256 accruedAmount, uint256 feeAmount, uint256 rate, uint256 utilization);\r\n    event LogAddAsset(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogAddBorrow(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogAddCollateral(address indexed user, uint256 amount);\r\n    event LogDev(address indexed newDev);\r\n    event LogExchangeRate(uint256 rate);\r\n    event LogFeeTo(address indexed newFeeTo);\r\n    event LogRemoveAsset(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogRemoveBorrow(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogRemoveCollateral(address indexed user, uint256 amount);\r\n    event LogWithdrawFees();\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function accrue() external;\r\n    function accrueInfo() external view returns (uint64 interestPerBlock, uint64 lastBlockAccrued, uint128 feesPendingAmount);\r\n    function addAsset(uint256 amount, bool useBento) external payable;\r\n    function addAssetTo(uint256 amount, address to, bool useBento) external payable;\r\n    function addCollateral(uint256 amount, bool useBento) external payable;\r\n    function addCollateralTo(uint256 amount, address to, bool useBento) external payable;\r\n    function allowance(address, address) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n    function asset() external view returns (IERC20);\r\n    function balanceOf(address) external view returns (uint256);\r\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory, bytes[] memory);\r\n    function bentoBox() external view returns (IBentoBox);\r\n    function borrow(uint256 amount, address to, bool useBento) external;\r\n    function claimOwnership() external;\r\n    function collateral() external view returns (IERC20);\r\n    function decimals() external view returns (uint8);\r\n    function dev() external view returns (address);\r\n    function exchangeRate() external view returns (uint256);\r\n    function feeTo() external view returns (address);\r\n    function getInitData(\r\n        IERC20 collateral_, IERC20 asset_, IOracle oracle_, bytes calldata oracleData_) external pure returns (bytes memory data);\r\n    function init(bytes calldata data) external;\r\n    function isSolvent(address user, bool open) external view returns (bool);\r\n    function liquidate(address[] calldata users, uint256[] calldata borrowFractions, address to, ISwapper swapper, bool open) external;\r\n    function masterContract() external view returns (ILendingPair);\r\n    function name() external view returns (string memory);\r\n    function nonces(address) external view returns (uint256);\r\n    function oracle() external view returns (IOracle);\r\n    function oracleData() external view returns (bytes memory);\r\n    function owner() external view returns (address);\r\n    function peekExchangeRate() external view returns (bool, uint256);\r\n    function pendingOwner() external view returns (address);\r\n    function permit(address owner_, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function permitToken(IERC20 token, address from, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function removeAsset(uint256 fraction, address to, bool useBento) external;\r\n    function removeCollateral(uint256 amount, address to, bool useBento) external;\r\n    function renounceOwnership() external;\r\n    function repay(uint256 fraction, bool useBento) external;\r\n    function repayFor(uint256 fraction, address beneficiary, bool useBento) external;\r\n    function setApproval(address user, bool approved, uint8 v, bytes32 r, bytes32 s) external;\r\n    function setDev(address newDev) external;\r\n    function setFeeTo(address newFeeTo) external;\r\n    function setSwapper(ISwapper swapper, bool enable) external;\r\n    function short(ISwapper swapper, uint256 assetAmount, uint256 minCollateralAmount) external;\r\n    function swappers(ISwapper) external view returns (bool);\r\n    function swipe(IERC20 token) external;\r\n    function symbol() external view returns (string memory);\r\n    function totalAsset() external view returns (uint128 amount, uint128 fraction);\r\n    function totalBorrow() external view returns (uint128 amount, uint128 fraction);\r\n    function totalCollateralAmount() external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool success);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool success);\r\n    function transferOwnership(address newOwner) external;\r\n    function transferOwnershipDirect(address newOwner) external;\r\n    function unwind(ISwapper swapper, uint256 borrowFraction, uint256 maxAmountCollateral) external;\r\n    function updateExchangeRate() external returns (uint256);\r\n    function userBorrowFraction(address) external view returns (uint256);\r\n    function userCollateralAmount(address) external view returns (uint256);\r\n    function withdrawFees() external;\r\n}"
    },
    "contracts/oracles/SimpleSLPTWAP1Oracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\n\r\n// Using the same Copyleft License as in the original Repository\r\n// solhint-disable not-rely-on-time\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\nimport \"../interfaces/IOracle.sol\";\r\nimport \"@bartjman/boring-solidity/contracts/libraries/BoringMath.sol\";\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\r\nimport \"../libraries/FixedPoint.sol\";\r\n\r\n// adapted from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol\r\n\r\ncontract SimpleSLPTWAP1Oracle is IOracle {\r\n    using FixedPoint for *;\r\n    using BoringMath for uint256;\r\n    uint256 public constant PERIOD = 5 minutes;\r\n\r\n    struct PairInfo {\r\n        uint256 priceCumulativeLast;\r\n        uint32 blockTimestampLast;\r\n        FixedPoint.uq112x112 priceAverage;\r\n    }\r\n\r\n    mapping(IUniswapV2Pair => PairInfo) public pairs; // Map of pairs and their info\r\n    mapping(address => IUniswapV2Pair) public callerInfo; // Map of callers to pairs\r\n\r\n    function _get(IUniswapV2Pair pair, uint32 blockTimestamp) public view returns (uint256) {\r\n        uint256 priceCumulative = pair.price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            priceCumulative += uint256(FixedPoint.fraction(reserve0, reserve1)._x) * (blockTimestamp - blockTimestampLast); // overflows ok\r\n        }\r\n\r\n        // overflow is desired, casting never truncates\r\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\r\n        return priceCumulative;\r\n    }\r\n\r\n    function getDataParameter(IUniswapV2Pair pair) public pure returns (bytes memory) { return abi.encode(pair); }\r\n\r\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\r\n    function get(bytes calldata data) external override returns (bool, uint256) {\r\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\r\n        if (pairs[pair].blockTimestampLast == 0) {\r\n            pairs[pair].blockTimestampLast = blockTimestamp;\r\n            pairs[pair].priceCumulativeLast = _get(pair, blockTimestamp);\r\n            return (false, 0);\r\n        }\r\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\r\n        if (timeElapsed < PERIOD) {\r\n            return (true, pairs[pair].priceAverage.mul(10**18).decode144());\r\n        }\r\n\r\n        uint256 priceCumulative = _get(pair, blockTimestamp);\r\n        pairs[pair].priceAverage = FixedPoint.uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed));\r\n        pairs[pair].blockTimestampLast = blockTimestamp;\r\n        pairs[pair].priceCumulativeLast = priceCumulative;\r\n\r\n        return (true, pairs[pair].priceAverage.mul(10**18).decode144());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    function peek(bytes calldata data) public override view returns (bool, uint256) {\r\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\r\n        if (pairs[pair].blockTimestampLast == 0) {\r\n            return (false, 0);\r\n        }\r\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\r\n        if (timeElapsed < PERIOD) {\r\n            return (true, pairs[pair].priceAverage.mul(10**18).decode144());\r\n        }\r\n\r\n        uint256 priceCumulative = _get(pair, blockTimestamp);\r\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint\r\n            .uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed));\r\n\r\n        return (true, priceAverage.mul(10**18).decode144());\r\n    }\r\n\r\n    function name(bytes calldata) public override view returns (string memory) {\r\n        return \"SushiSwap TWAP\";\r\n    }\r\n\r\n    function symbol(bytes calldata) public override view returns (string memory) {\r\n        return \"S\";\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\n\nimport \"./FullMath.sol\";\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // multiply a UQ112x112 by a uint256, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z = 0;\n        require(y == 0 || (z = self._x * y) / y == self._x, \"FixedPoint::mul: overflow\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // lossy if either numerator or denominator is greater than 112 bits\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint::fraction: div by 0\");\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= uint144(-1)) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        }\n    }\n}\n"
    },
    "contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: CC-BY-4.0\n// solium-disable security/no-assign-params\npragma solidity 0.6.12;\n\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n// license is CC-BY-4.0\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n        require(h < d, 'FullMath::mulDiv: overflow');\n        return fullDiv(l, h, d);\n    }\n}\n"
    },
    "contracts/oracles/SimpleSLPTWAP0Oracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\n\r\n// Using the same Copyleft License as in the original Repository\r\n// solhint-disable not-rely-on-time\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\nimport \"../interfaces/IOracle.sol\";\r\nimport \"@bartjman/boring-solidity/contracts/libraries/BoringMath.sol\";\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\r\nimport \"../libraries/FixedPoint.sol\";\r\n\r\n// adapted from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol\r\n\r\ncontract SimpleSLPTWAP0Oracle is IOracle {\r\n    using FixedPoint for *;\r\n    using BoringMath for uint256;\r\n    uint256 public constant PERIOD = 5 minutes;\r\n\r\n    struct PairInfo {\r\n        uint256 priceCumulativeLast;\r\n        uint32 blockTimestampLast;\r\n        FixedPoint.uq112x112 priceAverage;\r\n    }\r\n\r\n    mapping(IUniswapV2Pair => PairInfo) public pairs; // Map of pairs and their info\r\n    mapping(address => IUniswapV2Pair) public callerInfo; // Map of callers to pairs\r\n\r\n    function _get(IUniswapV2Pair pair, uint32 blockTimestamp) public view returns (uint256) {\r\n        uint256 priceCumulative = pair.price0CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            priceCumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * (blockTimestamp - blockTimestampLast); // overflows ok\r\n        }\r\n\r\n        // overflow is desired, casting never truncates\r\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\r\n        return priceCumulative;\r\n    }\r\n\r\n    function getDataParameter(IUniswapV2Pair pair) public pure returns (bytes memory) { return abi.encode(pair); }\r\n\r\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\r\n    function get(bytes calldata data) external override returns (bool, uint256) {\r\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\r\n        if (pairs[pair].blockTimestampLast == 0) {\r\n            pairs[pair].blockTimestampLast = blockTimestamp;\r\n            pairs[pair].priceCumulativeLast = _get(pair, blockTimestamp);\r\n\r\n            return (false, 0);\r\n        }\r\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\r\n        if (timeElapsed < PERIOD) {\r\n            return (true, pairs[pair].priceAverage.mul(10**18).decode144());\r\n        }\r\n\r\n        uint256 priceCumulative = _get(pair, blockTimestamp);\r\n        pairs[pair].priceAverage = FixedPoint.uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed));\r\n        pairs[pair].blockTimestampLast = blockTimestamp;\r\n        pairs[pair].priceCumulativeLast = priceCumulative;\r\n\r\n        return (true, pairs[pair].priceAverage.mul(10**18).decode144());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    function peek(bytes calldata data) public override view returns (bool, uint256) {\r\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\r\n        if (pairs[pair].blockTimestampLast == 0) {\r\n            return (false, 0);\r\n        }\r\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\r\n        if (timeElapsed < PERIOD) {\r\n            return (true, pairs[pair].priceAverage.mul(10**18).decode144());\r\n        }\r\n\r\n        uint256 priceCumulative = _get(pair, blockTimestamp);\r\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint\r\n            .uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed));\r\n\r\n        return (true, priceAverage.mul(10**18).decode144());\r\n    }\r\n\r\n    function name(bytes calldata) public override view returns (string memory) {\r\n        return \"SushiSwap TWAP\";\r\n    }\r\n\r\n    function symbol(bytes calldata) public override view returns (string memory) {\r\n        return \"S\";\r\n    }\r\n}\r\n"
    },
    "@sushiswap/core/contracts/uniswapv2/UniswapV2Pair.sol": {
      "content": "pragma solidity =0.6.12;\n\nimport './UniswapV2ERC20.sol';\nimport './libraries/Math.sol';\nimport './libraries/UQ112x112.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IUniswapV2Factory.sol';\nimport './interfaces/IUniswapV2Callee.sol';\n\n\ninterface IMigrator {\n    // Return the desired amount of liquidity token that the migrator wants.\n    function desiredLiquidity() external view returns (uint256);\n}\n\ncontract UniswapV2Pair is UniswapV2ERC20 {\n    using SafeMathUniswap  for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'UniswapV2: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\n    }\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() public {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n        address feeTo = IUniswapV2Factory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n                uint rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint denominator = rootK.mul(5).add(rootKLast);\n                    uint liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint balance0 = IERC20Uniswap(token0).balanceOf(address(this));\n        uint balance1 = IERC20Uniswap(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            address migrator = IUniswapV2Factory(factory).migrator();\n            if (msg.sender == migrator) {\n                liquidity = IMigrator(migrator).desiredLiquidity();\n                require(liquidity > 0 && liquidity != uint256(-1), \"Bad desired liquidity\");\n            } else {\n                require(migrator == address(0), \"Must not have migrator\");\n                liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n                _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n            }\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0;                                // gas savings\n        address _token1 = token1;                                // gas savings\n        uint balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\n        uint balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\n        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\n        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20Uniswap(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20Uniswap(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20Uniswap(token0).balanceOf(address(this)), IERC20Uniswap(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/UniswapV2ERC20.sol": {
      "content": "pragma solidity =0.6.12;\n\nimport './libraries/SafeMath.sol';\n\ncontract UniswapV2ERC20 {\n    using SafeMathUniswap for uint;\n\n    string public constant name = 'SushiSwap LP Token';\n    string public constant symbol = 'SLP';\n    uint8 public constant decimals = 18;\n    uint  public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor() public {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/libraries/Math.sol": {
      "content": "pragma solidity =0.6.12;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/libraries/UQ112x112.sol": {
      "content": "pragma solidity =0.6.12;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IERC20Uniswap {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Callee.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/libraries/SafeMath.sol": {
      "content": "pragma solidity =0.6.12;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMathUniswap {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n"
    },
    "contracts/mocks/SushiSwapPairMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"@sushiswap/core/contracts/uniswapv2/UniswapV2Pair.sol\";\n\ncontract SushiSwapPairMock is UniswapV2Pair {}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/UniswapV2Factory.sol": {
      "content": "pragma solidity =0.6.12;\n\nimport './interfaces/IUniswapV2Factory.sol';\nimport './UniswapV2Pair.sol';\n\ncontract UniswapV2Factory is IUniswapV2Factory {\n    address public override feeTo;\n    address public override feeToSetter;\n    address public override migrator;\n\n    mapping(address => mapping(address => address)) public override getPair;\n    address[] public override allPairs;\n\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    constructor(address _feeToSetter) public {\n        feeToSetter = _feeToSetter;\n    }\n\n    function allPairsLength() external override view returns (uint) {\n        return allPairs.length;\n    }\n\n    function pairCodeHash() external pure returns (bytes32) {\n        return keccak256(type(UniswapV2Pair).creationCode);\n    }\n\n    function createPair(address tokenA, address tokenB) external override returns (address pair) {\n        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(UniswapV2Pair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        UniswapV2Pair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    function setFeeTo(address _feeTo) external override {\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        feeTo = _feeTo;\n    }\n\n    function setMigrator(address _migrator) external override {\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        migrator = _migrator;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external override {\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        feeToSetter = _feeToSetter;\n    }\n\n}\n"
    },
    "contracts/mocks/SushiSwapFactoryMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/UniswapV2Factory.sol\";\n\ncontract SushiSwapFactoryMock is UniswapV2Factory {\n\tconstructor() public UniswapV2Factory(msg.sender) {}\n}\n"
    },
    "contracts/oracles/CompoundOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\nimport \"@bartjman/boring-solidity/contracts/libraries/BoringMath.sol\";\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\ninterface IUniswapAnchoredView {\r\n    function price(string memory symbol) external view returns (uint256);\r\n}\r\n\r\ncontract CompoundOracle is IOracle {\r\n    using BoringMath for uint256;\r\n\r\n    IUniswapAnchoredView constant private ORACLE = IUniswapAnchoredView(0x922018674c12a7F0D394ebEEf9B58F186CdE13c1);\r\n\r\n    struct PriceInfo {\r\n        uint128 price;\r\n        uint128 blockNumber;\r\n    }\r\n\r\n    mapping(string => PriceInfo) public prices;\r\n\r\n    function _peekPrice(string memory symbol_) internal view returns(uint256) {\r\n        if (bytes(symbol_).length == 0) {return 1000000;} // To allow only using collateralSymbol or assetSymbol if paired against USDx\r\n        PriceInfo memory info = prices[symbol_];\r\n        if (block.number > info.blockNumber + 8) {\r\n            return uint128(ORACLE.price(symbol_)); // Prices are denominated with 6 decimals, so will fit in uint128\r\n        }\r\n        return info.price;\r\n    }\r\n\r\n    function _getPrice(string memory symbol_) internal returns(uint256) {\r\n        if (bytes(symbol_).length == 0) {return 1000000;} // To allow only using collateralSymbol or assetSymbol if paired against USDx\r\n        PriceInfo memory info = prices[symbol_];\r\n        if (block.number > info.blockNumber + 8) {\r\n            info.price = uint128(ORACLE.price(symbol_)); // Prices are denominated with 6 decimals, so will fit in uint128\r\n            info.blockNumber = uint128(block.number); // Blocknumber will fit in uint128\r\n            prices[symbol_] = info;\r\n        }\r\n        return info.price;\r\n    }\r\n\r\n    function getDataParameter(string memory collateralSymbol, string memory assetSymbol, uint256 division) public pure returns (bytes memory) {\r\n        return abi.encode(collateralSymbol, assetSymbol, division);\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    function get(bytes calldata data) public override returns (bool, uint256) {\r\n        (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n        return (true, uint256(1e36).mul(_getPrice(assetSymbol)) / _getPrice(collateralSymbol) / division);\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    function peek(bytes calldata data) public override view returns(bool, uint256) {\r\n        (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n        return (true, uint256(1e36).mul(_peekPrice(assetSymbol)) / _peekPrice(collateralSymbol) / division);\r\n    }\r\n\r\n    function name(bytes calldata) public override view returns (string memory) {\r\n        return \"Compound\";\r\n    }\r\n\r\n    function symbol(bytes calldata) public override view returns (string memory) {\r\n        return \"COMP\";\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/CompositeOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n// Using the same Copyleft License as in the original Repository\npragma solidity 0.6.12;\nimport \"@bartjman/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../interfaces/IOracle.sol\";\n\ncontract CompositeOracle is IOracle {\n    using BoringMath for uint256;\n\n    function getDataParameter(IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) public pure returns (bytes memory) {\n        return abi.encode(oracle1, oracle2, data1, data2);\n    }\n\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\n    function get(bytes calldata data) external override returns (bool status, uint256 amountOut){\n        (IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) = abi.decode(data, (IOracle, IOracle, bytes, bytes));\n        (bool success1, uint256 price1) = oracle1.get(data1);\n        (bool success2, uint256 price2) = oracle2.get(data2);\n        return (success1 && success2, price1.mul(price2) / 10**18);\n    }\n\n    // Check the last exchange rate without any state changes\n    function peek(bytes calldata data) public override view returns (bool success, uint256 amountOut) {\n        (IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) = abi.decode(data, (IOracle, IOracle, bytes, bytes));\n        (bool success1, uint256 price1) = oracle1.peek(data1);\n        (bool success2, uint256 price2) = oracle2.peek(data2);\n        return (success1 && success2, price1.mul(price2) / 10**18);\n    }\n\n    function name(bytes calldata data) public override view returns (string memory) {\n        (IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) = abi.decode(data, (IOracle, IOracle, bytes, bytes));\n        return string(abi.encodePacked(oracle1.name(data1), \"+\", oracle2.name(data2)));\n    }\n\n    function symbol(bytes calldata data) public override view returns (string memory) {\n        (IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) = abi.decode(data, (IOracle, IOracle, bytes, bytes));\n        return string(abi.encodePacked(oracle1.symbol(data1), \"+\", oracle2.symbol(data2)));\n    }\n}\n"
    },
    "contracts/oracles/ChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\nimport \"@bartjman/boring-solidity/contracts/libraries/BoringMath.sol\";\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\ninterface IAggregator {\r\n    function latestRoundData() external view returns (uint80, int256 answer, uint256, uint256, uint80);\r\n}\r\n\r\ncontract ChainlinkOracle is IOracle {\r\n    using BoringMath for uint256; // Keep everything in uint256\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get(address multiply, address divide, uint256 decimals) public view returns (uint256) {\r\n        uint256 price = uint256(1e18);\r\n        if (multiply != address(0)) {\r\n            // We only care about the second value - the price\r\n            (, int256 priceC,,,) = IAggregator(multiply).latestRoundData();\r\n            price = price.mul(uint256(priceC));\r\n        } else {\r\n            price = price.mul(1e18);\r\n        }\r\n\r\n        if (divide != address(0)) {\r\n            // We only care about the second value - the price\r\n            (, int256 priceC,,,) = IAggregator(divide).latestRoundData();\r\n            price = price / uint256(priceC);\r\n        }\r\n\r\n        return price / decimals;\r\n    }\r\n\r\n    function getDataParameter(address multiply, address divide, uint256 decimals) public pure returns (bytes memory) {\r\n        return abi.encode(multiply, divide, decimals);\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    function get(bytes calldata data) public override returns (bool, uint256) {\r\n        (address multiply, address divide, uint256 decimals) = abi.decode(data, (address, address, uint256));\r\n        return (true, _get(multiply, divide, decimals));\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    function peek(bytes calldata data) public override view returns (bool, uint256) {\r\n        (address multiply, address divide, uint256 decimals) = abi.decode(data, (address, address, uint256));\r\n        return (true, _get(multiply, divide, decimals));\r\n    }\r\n\r\n    function name(bytes calldata) public override view returns (string memory) {\r\n        return \"Chainlink\";\r\n    }\r\n\r\n    function symbol(bytes calldata) public override view returns (string memory) {\r\n        return \"LINK\";\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/OracleMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\nimport \"@bartjman/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../interfaces/IOracle.sol\";\n\n// WARNING: This oracle is only for testing, please use PeggedOracle for a fixed value oracle\ncontract OracleMock is IOracle {\n\tusing BoringMath for uint256;\n\n\tuint256 rate;\n\n\tfunction set(uint256 rate_, address) public {\n\t\t// The rate can be updated.\n\t\trate = rate_;\n\t}\n\n\tfunction getDataParameter() public pure returns (bytes memory) {\n\t\treturn abi.encode(\"0x0\");\n\t}\n\n\t// Get the latest exchange rate\n\tfunction get(bytes calldata) public override returns (bool, uint256) {\n\t\treturn (true, rate);\n\t}\n\n\t// Check the last exchange rate without any state changes\n\tfunction peek(bytes calldata) public view override returns (bool, uint256) {\n\t\treturn (true, rate);\n\t}\n\n\tfunction name(bytes calldata) public view override returns (string memory) {\n\t\treturn \"Test\";\n\t}\n\n\tfunction symbol(bytes calldata) public view override returns (string memory) {\n\t\treturn \"TEST\";\n\t}\n}\n"
    },
    "contracts/oracles/PeggedOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\ncontract PeggedOracle is IOracle {\r\n    function getDataParameter(uint256 rate) public pure returns (bytes memory) { return abi.encode(rate); }\r\n\r\n    // Get the exchange rate\r\n    function get(bytes calldata data) public override returns (bool, uint256) {\r\n        uint256 rate = abi.decode(data, (uint256));\r\n        return (rate != 0, rate);\r\n    }\r\n\r\n    // Check the exchange rate without any state changes\r\n    function peek(bytes calldata data) public override view returns (bool, uint256) {\r\n        uint256 rate = abi.decode(data, (uint256));\r\n        return (rate != 0, rate);\r\n    }\r\n\r\n    function name(bytes calldata) public override view returns (string memory) {\r\n        return \"Pegged\";\r\n    }\r\n\r\n    function symbol(bytes calldata) public override view returns (string memory) {\r\n        return \"PEG\";\r\n    }\r\n}"
    },
    "contracts/BentoHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"./interfaces/ILendingPair.sol\";\nimport \"./interfaces/IOracle.sol\";\n\ncontract BentoHelper {\n    struct PairInfo {\n        ILendingPair pair;\n        IOracle oracle;\n        IBentoBox bentoBox;\n        address masterContract;\n        bool masterContractApproved;\n        IERC20 tokenAsset;\n        IERC20 tokenCollateral;\n\n        uint256 latestExchangeRate;\n        uint256 lastBlockAccrued;\n        uint256 interestRate;\n        uint256 totalCollateralAmount;\n        uint256 totalAssetAmount;\n        uint256 totalBorrowAmount;\n\n        uint256 totalAssetFraction;\n        uint256 totalBorrowFraction;\n\n        uint256 interestPerBlock;\n\n        uint256 feesPendingAmount;\n\n        uint256 userCollateralAmount;\n        uint256 userAssetFraction;\n        uint256 userAssetAmount;\n        uint256 userBorrowFraction;\n        uint256 userBorrowAmount;\n\n        uint256 userAssetBalance;\n        uint256 userCollateralBalance;\n        uint256 userAssetAllowance;\n        uint256 userCollateralAllowance;\n    }\n\n    function getPairs(address user, ILendingPair[] calldata pairs) public view returns (PairInfo[] memory info) {\n        info = new PairInfo[](pairs.length);\n        for(uint256 i = 0; i < pairs.length; i++) {\n            ILendingPair pair = pairs[i];\n            info[i].pair = pair;\n            info[i].oracle = pair.oracle();\n            IBentoBox bentoBox = pair.bentoBox();\n            info[i].bentoBox = bentoBox;\n            info[i].masterContract = address(pair.masterContract());\n            info[i].masterContractApproved = bentoBox.masterContractApproved(info[i].masterContract, user);\n            IERC20 asset = pair.asset();\n            info[i].tokenAsset = asset;\n            IERC20 collateral = pair.collateral();\n            info[i].tokenCollateral = collateral;\n\n            (, info[i].latestExchangeRate) = pair.peekExchangeRate();\n            (info[i].interestPerBlock, info[i].lastBlockAccrued, info[i].feesPendingAmount) = pair.accrueInfo();\n            info[i].totalCollateralAmount = pair.totalCollateralAmount();\n            (info[i].totalAssetAmount, info[i].totalAssetFraction ) = pair.totalAsset();\n            (info[i].totalBorrowAmount, info[i].totalBorrowFraction) = pair.totalBorrow();\n\n            info[i].userCollateralAmount = pair.userCollateralAmount(user);\n            info[i].userAssetFraction = pair.balanceOf(user);\n            info[i].userAssetAmount = info[i].totalAssetFraction == 0 ? 0 :\n                 info[i].userAssetFraction * info[i].totalAssetAmount / info[i].totalAssetFraction;\n            info[i].userBorrowFraction = pair.userBorrowFraction(user);\n            info[i].userBorrowAmount = info[i].totalBorrowFraction == 0 ? 0 :\n                info[i].userBorrowFraction * info[i].totalBorrowAmount / info[i].totalBorrowFraction;\n\n            info[i].userAssetBalance = info[i].tokenAsset.balanceOf(user);\n            info[i].userCollateralBalance = info[i].tokenCollateral.balanceOf(user);\n            info[i].userAssetAllowance = info[i].tokenAsset.allowance(user, address(bentoBox));\n            info[i].userCollateralAllowance = info[i].tokenCollateral.allowance(user, address(bentoBox));\n        }\n    }\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"@bartjman/boring-solidity/contracts/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n\tuint256 public totalSupply;\n\n\tconstructor(uint256 _initialAmount) public {\n\t\t// Give the creator all initial tokens\n\t\tbalanceOf[msg.sender] = _initialAmount;\n\t\t// Update total supply\n\t\ttotalSupply = _initialAmount;\n\t}\n}\n"
    },
    "contracts/mocks/OwnableMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@bartjman/boring-solidity/contracts/BoringOwnable.sol\";\n\n\ncontract OwnableMock is BoringOwnable {}\n"
    },
    "contracts/mocks/MasterContractManagerMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"../MasterContractManager.sol\";\n\ncontract MasterContractManagerMock is MasterContractManager {}\n"
    },
    "contracts/mocks/FlashLoanerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solium-disable security/no-tx-origin\n\n// TokenA does not revert on errors, it just returns false\npragma solidity 0.6.12;\nimport \"../BentoBoxPlus.sol\";\n\ncontract FlashLoanerMock is IFlashLoaner{\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n    function executeOperation(IERC20[] calldata tokens, uint256[] calldata amounts, uint256[] calldata fees, bytes calldata params) public override {\n        address bentoBox = address(msg.sender);\n        uint256 payback = amounts[0].add(fees[0]);\n        uint256 money = tokens[0].balanceOf(address(this));\n        tokens[0].safeTransfer(address(bentoBox), payback);\n        uint256 winnings = money.sub(payback);\n        tokens[0].safeTransfer(address(tx.origin), winnings);\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 500
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}